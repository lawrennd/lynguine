---
id: "cip0006"
title: "Configuration Template Expansion System"
status: "Proposed"
priority: "Medium"
effort: "Medium"
type: "feature"
created: "2025-12-22"
last_updated: "2025-12-22"
owner: "lawrennd"
github_issue: null
dependencies: null
---

# CIP-0006: Configuration Template Expansion System

## Status

- [x] Proposed: 2025-12-22
- [ ] Accepted
- [ ] Implemented
- [ ] Closed

## Description

Implement a template expansion system in referia to reduce repetition in configuration files by allowing users to define reusable patterns that can be instantiated with different parameters. This is particularly valuable for PhD thesis review configurations where the same review structure (summary, general comments, detailed comments, questions, custom query) is repeated for 12+ chapters with only the identifier changing (e.g., `ch1`, `ch2`, `prologue`, `epilogue`).

## Motivation

### Current Problem

PhD thesis review configurations contain extensive repetition. For example, in `referia/theses/drafts/introduction/_referia.yml`, the same 100+ line pattern is repeated for each chapter:

```yaml
- type: Checkbox
  field: ch1SummaryIncludeHistory
  args:
    description: "Include custom query conversation as context"
    default: false
- type: Textarea
  field: ch1Summary
  args:
    description: "Summary"
    rows: 10
- type: PopulateButton
  args:
    target: ch1Summary
    compute:
      field: ch1Summary
      function: llm_pdf_review
      # ... many more lines
```

This same structure is repeated for `ch2`, `ch3`, ... `ch12`, `prologue`, `epilogue`, etc., resulting in:

- **2700+ lines** of configuration
- **Difficult maintenance**: Changes to the pattern require updating 12+ locations
- **Error-prone**: Easy to miss updates or introduce inconsistencies
- **Poor readability**: Hard to see the overall structure

### Proposed Solution

Allow users to define templates and instantiate them:

```yaml
templates:
  chapter_review:
    file: ../templates/chapter_review.yml
    # Or inline definition

review:
  - template: chapter_review
    instances:
      - prefix: prologue
        filename: "{Name}_thesis_prologue.pdf"
        pages: {first: PrologueFP, last: PrologueLP}
      - prefix: ch1
        filename: "{Name}_thesis_ch1.pdf"
        pages: {first: Ch1FP, last: Ch1LP}
      - prefix: ch2
        filename: "{Name}_thesis_ch2.pdf"
        pages: {first: Ch2FP, last: Ch2LP}
      # ... etc
```

This reduces the configuration to ~50 lines while maintaining the same functionality.

## Design Philosophy Alignment

### Explicit Infrastructure (lynguine)

From the **Explicit Infrastructure** tenet:

> *"lynguine is a Data Oriented Architecture (DOA) infrastructure library that should be explicit, machine-understandable, and predictable."*

**Key principle**: *"Show me the data flow, make everything explicit"*

**How this aligns**:

- Templates are **explicitly defined** (not hidden)
- Template references are **explicit** (clear what's being used)
- Expansion happens **explicitly** (in referia's Interface)
- lynguine receives **fully expanded** configuration (no magic)
- Expansion is **traceable** (can inspect before/after)

### Flow-Based Processing

From the **Flow-Based Processing** tenet:

> *"Processing should be explicit and happen during flow execution, not during object construction."*

**How this aligns**:

- Expansion occurs during **explicit flow processing** (in `Interface.__init__()`)
- Not hidden in construction or implicit preprocessing
- Part of the documented data transformation flow
- Each stage is explicit and inspectable

### Application vs Infrastructure Layer

Based on CIP-0003's layering principles:

**lynguine (Infrastructure)**:
- Provides explicit, predictable APIs
- Implements flow-based processing
- Maintains strict separation of concerns
- No implicit behaviour

**referia (Application)**:
- Builds user-friendly interfaces on lynguine
- Provides user convenience
- Handles domain-specific patterns (e.g., document reviews)
- May provide implicit behaviour for users, but implements it explicitly

**Decision**: Template expansion belongs in **referia**, not lynguine.

#### Why Referia, Not Lynguine?

1. **Domain-Specific**: Document review patterns are referia's domain, not general infrastructure
2. **User Convenience**: Templates provide user convenience, which is referia's role
3. **Explicit Implementation**: referia implements template expansion explicitly while providing implicit convenience to users
4. **Clean Separation**: lynguine remains a pure infrastructure library with no domain-specific features

#### Architectural Boundaries

The boundary is clear:

- **lynguine**: Receives fully expanded, explicit configuration. Never sees templates or understands template syntax.
- **referia**: Performs template expansion explicitly in its Interface layer, then passes explicit configuration to lynguine.

This maintains the layering principle: applications (referia) can provide convenience features by building on infrastructure (lynguine), but infrastructure never depends on application-specific features.

#### Maintaining Explicitness

While templates provide "implicit" convenience to users (less typing), the implementation is explicit:

- Templates are **explicitly defined** in configuration
- Template references are **explicit** (not inferred or guessed)
- Expansion happens at a **defined point** (Interface.__init__())
- Result is **fully explicit** (lynguine sees complete config)
- Process is **traceable** (can log and inspect expansion)

This aligns with the design philosophy: users get convenience, but the system remains explicit and predictable.

## Implementation

### Architecture

Template expansion will be implemented in referia's `Interface` class:

```python
class Interface(lynguine.config.interface.Interface):
    def __init__(self, data=None, directory=None, user_file=None):
        # Expand templates before passing to lynguine
        if "templates" in data or self._has_template_references(data):
            data = self._expand_templates(data)
        
        # Pass explicit, expanded config to lynguine
        super().__init__(data=data, directory=directory, user_file=user_file)
    
    def _expand_templates(self, data):
        """
        Explicitly expand template patterns into full configuration.
        
        This transforms compact template specifications into the full
        explicit configuration that lynguine expects.
        """
        # 1. Load template definitions
        templates = self._load_templates(data)
        
        # 2. Find template references in configuration
        # 3. Expand each reference with its parameters
        # 4. Return fully expanded configuration
        pass
```

### Template Definition Format

#### Inline Templates

```yaml
templates:
  chapter_review:
    pattern:
      - type: Checkbox
        field: {prefix}SummaryIncludeHistory
        args:
          description: "Include custom query conversation as context"
          default: false
      - type: Textarea
        field: {prefix}Summary
        args:
          description: "Summary"
          placeholder: "LLM-generated summary will appear here..."
          rows: 10
      # ... rest of pattern
```

#### External Template Files

```yaml
templates:
  chapter_review:
    file: ../templates/chapter_review.yml
```

Where `chapter_review.yml` contains:

```yaml
pattern:
  - type: Checkbox
    field: {prefix}SummaryIncludeHistory
    # ... rest of pattern
```

### Template Usage

```yaml
review:
  - template: chapter_review
    instances:
      - prefix: ch1
        filename: "{Name}_thesis_ch1.pdf"
        start_page: Ch1FP
        end_page: Ch1LP
      - prefix: ch2
        filename: "{Name}_thesis_ch2.pdf"
        start_page: Ch2FP
        end_page: Ch2LP
```

### Parameter Substitution

Templates support parameter substitution using `{parameter}` syntax:

- `{prefix}` → `ch1`, `ch2`, etc.
- `{filename}` → `"{Name}_thesis_ch1.pdf"`
- `{start_page}` → `Ch1FP`
- Nested substitution: `{prefix}Summary` → `ch1Summary`

### Expansion Process

1. **Load Templates**: Read template definitions from inline or external sources
2. **Validate Templates**: Check for required parameters, valid structure
3. **Find References**: Locate template usage in configuration
4. **Expand Instances**: For each instance, substitute parameters and generate configuration
5. **Merge Results**: Insert expanded configuration into the appropriate location
6. **Return Explicit Config**: Pass fully expanded configuration to lynguine

### Expansion Timing

Template expansion occurs at a well-defined point in the data flow:

1. **After** configuration file is loaded (YAML parsed into dict)
2. **During** referia's `Interface.__init__()` processing
3. **Before** lynguine's `Interface.__init__()` is called

This ensures:

- Expansion is **explicit** (happens in referia layer)
- Result is **explicit** (lynguine sees fully expanded config)
- Flow is **traceable** (can inspect pre and post expansion)
- No hidden preprocessing or construction-time magic

**Flow diagram**:

```
User writes config → YAML loaded → referia.Interface.__init__()
                                           ↓
                                    _expand_templates()
                                           ↓
                                    Explicit config → lynguine.Interface.__init__()
                                                            ↓
                                                      from_flow() processing
```

### Error Handling

Provide clear, actionable error messages:

```python
# Missing template
raise ValueError(
    f"Template 'chapter_review' referenced but not defined. "
    f"Available templates: {list(templates.keys())}"
)

# Missing required parameter
raise ValueError(
    f"Template 'chapter_review' requires parameter 'prefix' "
    f"but it was not provided in instance {i}"
)

# Invalid template structure
raise ValueError(
    f"Template 'chapter_review' has invalid structure: "
    f"expected 'pattern' key but found {list(template.keys())}"
)
```

### Debugging Support

Provide tools to inspect expansion:

```python
# Log expansion at DEBUG level
log.debug(f"Expanding template '{template_name}' with {len(instances)} instances")
log.debug(f"Instance {i}: {instance_params}")

# Option to dump expanded configuration
if log.level <= logging.DEBUG:
    with open(f"{user_file}.expanded.yml", 'w') as f:
        yaml.dump(expanded_data, f)
```

## Implementation Status

- [ ] Design template definition format
- [ ] Implement template loading (inline and external)
- [ ] Implement parameter substitution
- [ ] Implement template expansion logic
- [ ] Add error handling and validation
- [ ] Add debugging support
- [ ] Write tests for template expansion
- [ ] Update documentation
- [ ] Create example templates
- [ ] Migrate existing configurations (optional)

## Benefits

### For Users

- **Reduced Repetition**: Write pattern once, use many times
- **Maintainability**: Update pattern in one place
- **Readability**: Compact, understandable configurations
- **Flexibility**: Can still write explicit config when needed
- **Reusability**: Share templates across projects

### For Architecture

- **Maintains Explicitness**: Templates are explicit, expansion is explicit
- **Proper Layering**: Convenience in referia, purity in lynguine
- **Traceability**: Can inspect both compact and expanded forms
- **No Magic**: Clear transformation process

### For Maintenance

- **Single Source of Truth**: Pattern defined once
- **Consistency**: All instances use same pattern
- **Easy Updates**: Change pattern, all instances updated
- **Reduced Errors**: Fewer places to make mistakes

## Backward Compatibility

- Existing explicit configurations continue to work unchanged
- Template expansion is **optional**
- No breaking changes to existing files
- Can mix templates and explicit configuration

## Testing Strategy

### Test-Driven Development Approach

This feature **must be developed using Test-Driven Development (TDD)**:

1. **Write tests first** before implementation
2. **Watch them fail** (red)
3. **Implement minimum code** to pass (green)
4. **Refactor** while keeping tests green

**Rationale**:
- Template expansion is core infrastructure that must be robust
- TDD ensures comprehensive test coverage from the start
- Tests serve as executable specification of behaviour
- Easier to refactor with confidence
- Aligns with lynguine's explicit, predictable design philosophy

### Test Categories

#### Unit Tests (Write First)

Test individual components in isolation:

- **Template Loading**:
  - [ ] Load inline template definition
  - [ ] Load external template from file
  - [ ] Handle missing template file
  - [ ] Handle malformed template YAML
  - [ ] Handle template with no pattern
  - [ ] Multiple templates in one config

- **Parameter Substitution**:
  - [ ] Simple substitution (`{prefix}` → `ch1`)
  - [ ] Nested substitution (`{prefix}Summary` → `ch1Summary`)
  - [ ] Multiple parameters in one string
  - [ ] Missing parameter (should error)
  - [ ] Extra parameters (should be ignored)
  - [ ] Empty parameter value
  - [ ] Special characters in parameters

- **Template Expansion**:
  - [ ] Single instance expansion
  - [ ] Multiple instances expansion
  - [ ] Nested template references
  - [ ] Template with no instances (should warn/error)
  - [ ] Template reference to non-existent template (should error)
  
- **Error Handling**:
  - [ ] Clear message for missing template
  - [ ] Clear message for missing required parameter
  - [ ] Clear message for invalid template structure
  - [ ] Clear message for circular template references
  - [ ] Error includes context (which template, which instance)

#### Integration Tests (Write After Unit Tests Pass)

Test full template expansion in context:

- [ ] Full configuration expansion with templates
- [ ] Integration with referia Interface
- [ ] Integration with lynguine Interface (receives explicit config)
- [ ] Real-world thesis review configuration
- [ ] Mixed template and explicit review entries
- [ ] Multiple different templates in one config
- [ ] Template in review section with other config sections

#### Validation Tests (Write After Integration Tests Pass)

Test that expanded configuration is correct:

- [ ] Expanded configuration is valid lynguine config
- [ ] All required fields are present
- [ ] Parameter substitution is complete (no `{...}` remain)
- [ ] No template artifacts remain (`template:`, `instances:`)
- [ ] Expanded config matches manually-written equivalent
- [ ] Field types are preserved (strings stay strings, etc.)

#### Regression Tests

Test against real configurations:

- [ ] `theses/drafts/introduction/_referia.yml` (2719 lines)
- [ ] `theses/examined/introduction/_referia.yml` (3564 lines)
- [ ] Expanded config produces same UI as explicit config
- [ ] No functional differences in behaviour

### Test Organization

```
tests/
├── unit/
│   ├── test_template_loading.py
│   ├── test_parameter_substitution.py
│   ├── test_template_expansion.py
│   └── test_error_handling.py
├── integration/
│   ├── test_interface_integration.py
│   ├── test_full_config_expansion.py
│   └── test_mixed_template_explicit.py
├── validation/
│   ├── test_expanded_config_validity.py
│   └── test_parameter_completion.py
└── regression/
    ├── test_thesis_review_configs.py
    └── fixtures/
        ├── simple_template.yml
        ├── complex_template.yml
        └── real_config_sample.yml
```

### Example Test (TDD)

**Step 1: Write failing test**:
```python
def test_simple_parameter_substitution():
    """Test that {prefix} is substituted correctly."""
    template = {"pattern": [{"field": "{prefix}Summary"}]}
    instance = {"prefix": "ch1"}
    
    result = expand_template(template, instance)
    
    assert result == [{"field": "ch1Summary"}]
```

**Step 2: Run test** (should fail - function doesn't exist)

**Step 3: Implement minimum code** to pass:
```python
def expand_template(template, instance):
    pattern = template["pattern"]
    result = []
    for item in pattern:
        new_item = {}
        for key, value in item.items():
            if isinstance(value, str):
                new_item[key] = value.format(**instance)
            else:
                new_item[key] = value
        result.append(new_item)
    return result
```

**Step 4: Run test** (should pass)

**Step 5: Refactor** if needed (extract methods, improve names, etc.)

### Coverage Requirements

- **Unit tests**: 100% code coverage for template expansion module
- **Integration tests**: All major configuration patterns covered
- **Validation tests**: All output properties verified
- **Regression tests**: All existing real-world configs tested

### Continuous Testing

- Run unit tests on every save (watch mode)
- Run all tests before every commit
- Run regression tests before every PR
- Include tests in CI/CD pipeline

## Documentation

### User Documentation

- How to define templates
- How to use templates
- Parameter substitution syntax
- Examples for common patterns
- Troubleshooting guide

### Developer Documentation

- Template expansion architecture
- Implementation details
- Extension points
- Design philosophy alignment

### Migration Guide

- How to convert existing configurations to use templates
- Best practices for template design
- When to use templates vs explicit config

## Future Considerations

### Template Expansion for Other Configuration Sections

While this CIP focuses on `review:` section templates, the same repetition pattern exists in other configuration sections:

#### `editpdf:` Section Repetition

The `editpdf:` section in thesis review configs shows similar repetition:

```yaml
editpdf:
- sourcedirectory: $HOME/Documents/
  storedirectory: $HOME/Documents/theses/drafts/
  pages:
    first: Ch1FP
    last: Ch1LP
  field: Ch1
  name: thesis_ch1
- sourcedirectory: $HOME/Documents/
  storedirectory: $HOME/Documents/theses/drafts/
  pages:
    first: Ch2FP
    last: Ch2LP
  field: Ch2
  name: thesis_ch2
# ... repeated 12+ times
```

**Questions for future design**:
1. Should `editpdf` support templates similar to `review`?
2. Is the repetition pattern similar enough to share template infrastructure?
3. Should template expansion be generalized across all configuration sections?

#### Compute Interface Integration

A broader architectural question:

**Should `editpdf` and viewer file commands be reconfigured to run through the compute interface rather than as separate entities?**

**Current state**:
- `editpdf`, `viewer`, `documents` are separate configuration sections
- Each has its own processing logic
- No relationship to the compute framework

**Potential future state**:
- These could be compute functions
- Leverage existing compute infrastructure (function registry, argument resolution, etc.)
- More consistent architecture
- Template expansion would work naturally through compute specs

**Implications**:
- **Pros**: Architectural consistency, leverage existing infrastructure, natural template support
- **Cons**: Breaking change, more complex migration, may not fit compute model perfectly

**Recommendation**: 
- Implement review templates first (this CIP)
- Create separate investigation task for compute integration
- Evaluate whether to generalize templates or integrate with compute

**Related investigation needed**: See backlog task `2025-12-22_investigate-compute-integration-for-config-sections.md`

### Template Expansion for Column Name Lists

Another source of repetition is column name specifications:

```yaml
output:
  columns:
  - abstractGeneralComments
  - abstractDetailedComments
  - abstractSummary
  - abstractQuestions
  - ch1GeneralComments
  - ch1DetailedComments
  - ch1Summary
  - ch1Questions
  # ... repeated for ch2, ch3, ... ch12 (100+ column names)
```

The pattern is `{prefix}{suffix}` where prefixes are chapter identifiers and suffixes are field types.

**Template solution**:

```yaml
output:
  columns:
  - template: cartesian
    prefixes: [abstract, ch1, ch2, ch3, ch4, ch5, ch6, ch7, ch8, ch9, ch10, ch11, ch12]
    suffixes: [GeneralComments, DetailedComments, Summary, Questions, CustomPrompt, CustomResponse, IncludeHistory, SummaryIncludeHistory]
```

**Considerations**:
- This is a simpler case than review templates (string concatenation vs nested structures)
- Could share template infrastructure or use separate mechanism
- Should use consistent syntax and approach

**Related task**: See backlog task `2025-12-22_template-expansion-for-column-lists.md`

## Related

- **Tenet**: Explicit Infrastructure (`lynguine/tenets/lynguine/explicit-infrastructure.md`)
- **Tenet**: Flow-Based Processing (`lynguine/tenets/lynguine/flow-based-processing.md`)
- **CIP**: 0003 (Consistent Mapping Initialization - layering principles)
- **Backlog**: 2025-12-22_implement-template-expansion
- **Future Investigation**: 2025-12-22_investigate-compute-integration-for-config-sections

## References

- Current thesis review configurations showing repetition:
  - `referia/theses/drafts/introduction/_referia.yml` (2719 lines)
  - `referia/theses/examined/introduction/_referia.yml` (3564 lines)
- Existing pattern expansion in referia:
  - `expand_composite_review()` in `referia/config/interface.py` (lines 409-594)
  - Shows precedent for pattern expansion in referia layer

## Author and Date

- **Author**: Neil D. Lawrence
- **Created**: 2025-12-22
- **Last Updated**: 2025-12-22

