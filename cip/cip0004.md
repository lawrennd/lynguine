---
id: "cip0004"
title: "LLM Integration via LangChain for Compute Framework"
status: "proposed"
priority: "medium"
effort: "medium"
type: "feature-extraction"
created: "2025-11-06"
last_updated: "2025-12-21"
owner: "lawrennd"
github_issue: null
dependencies: "referia-cip0006"
related_cips: "referia CIP-0006 (implemented)"
---

# CIP-0004: Extract LLM Integration from Referia to Lynguine

## Status

- [x] Proposed: 2025-11-06
- [x] Referia Implementation Complete: 2025-11-07 (CIP-0006)
- [ ] Accepted for Extraction
- [ ] Implemented in Lynguine
- [ ] Closed

## Update 2025-12-21: Referia Implementation Complete

**Key Finding**: Referia has successfully implemented comprehensive LLM integration (CIP-0006, status: `implemented`). This CIP now focuses on **extracting generic components** from referia's proven implementation into lynguine for use by other applications.

**What's Already Working in Referia**:
- ✅ LLMManager class with multi-provider support (OpenAI, Anthropic)
- ✅ 7 LLM compute functions (complete, summarise, extract, classify, chat, pdf_review, custom_query)
- ✅ Cost tracking and budget enforcement
- ✅ Retry logic with exponential backoff
- ✅ Response caching with TTL
- ✅ 16 comprehensive tests (all passing)
- ✅ Full documentation and examples
- ✅ Production use in referia

**See**: `cip0004_referia_analysis.md` for detailed analysis of referia implementation.

## Description

This CIP proposes **extracting** proven LLM capabilities from referia into lynguine's compute framework. Rather than building from scratch, we will extract and generalize the working implementation from referia CIP-0006.

**Extraction Strategy**:
1. Extract generic infrastructure from `referia/util/llm.py` → `lynguine/util/llm.py`
2. Extract generic compute functions → `lynguine/assess/compute.py`
3. Leave domain-specific code (PDF review, assessment prompts) in referia
4. Update referia to import from lynguine after extraction

**What Lynguine Will Gain**:
- LLMManager class (provider abstraction, retry, caching, cost tracking)
- Generic LLM compute functions (complete, chat, summarise, extract, classify)
- Configuration schema for LLM settings
- Comprehensive tests and documentation

**What Stays in Referia**:
- Domain-specific functions (llm_pdf_review, llm_custom_query)
- Review-specific prompts and templates
- Assessment workflow integrations

## Motivation

### Current Capabilities

The compute framework currently provides excellent text processing capabilities through spaCy (word_count, named_entities, text_summarizer) and Liquid templates for formatting. However, these approaches have limitations:

1. **Rule-based Processing**: Current text analysis is primarily rule-based and statistical
2. **Limited Understanding**: Cannot handle complex semantic reasoning or context-dependent tasks
3. **Fixed Functionality**: Adding new text processing capabilities requires Python code changes
4. **No Generative Capabilities**: Cannot generate creative or context-aware text content

### Use Cases for LLM Integration

LLMs would enable new capabilities crucial for referia's review workflows:

#### 1. Intelligent Review Analysis
```yaml
compute:
  - function: llm_analyze
    field: review_quality_assessment
    row_args:
      text: review_text
    args:
      prompt: |
        Analyze this peer review for:
        1. Constructiveness
        2. Technical depth
        3. Clarity
        Return a JSON object with scores 1-5 for each.
      model: gpt-4
```

#### 2. Contextual Summarization
```yaml
compute:
  - function: llm_summarize
    field: contextual_summary
    row_args:
      text: review_text
      context: paper_abstract
    args:
      prompt: "Summarize this review in the context of the paper abstract"
      max_tokens: 150
```

#### 3. Classification and Tagging
```yaml
compute:
  - function: llm_classify
    field: review_categories
    row_args:
      text: review_text
    args:
      prompt: "Classify this review into categories: methodology, results, writing, significance"
      output_format: json
```

#### 4. Question Answering
```yaml
compute:
  - function: llm_qa
    field: response_to_query
    row_args:
      context: review_text
    args:
      question: "What are the main concerns raised in this review?"
```

#### 5. Sentiment and Tone Analysis
```yaml
compute:
  - function: llm_sentiment
    field: review_tone
    row_args:
      text: review_text
    args:
      aspects: ["constructiveness", "professionalism", "specificity"]
```

### Why LangChain?

LangChain provides:
- **Provider Abstraction**: Support multiple LLM providers with consistent API
- **Prompt Templates**: Structured prompt management
- **Chain Support**: Complex multi-step LLM workflows
- **Memory Systems**: Context management for conversations
- **Output Parsers**: Structured output extraction
- **Active Development**: Well-maintained with growing ecosystem

## Detailed Description

### Architecture Overview

```
┌─────────────────────────────────────────────────────────────┐
│                   Compute Framework                          │
│                                                              │
│  ┌──────────────────────────────────────────────────────┐  │
│  │           Function Registry                           │  │
│  │                                                        │  │
│  │  ┌─────────────────┐  ┌──────────────────────────┐  │  │
│  │  │ Traditional      │  │ LLM Functions (NEW)      │  │  │
│  │  │ Functions        │  │                          │  │  │
│  │  │ - word_count     │  │ - llm_analyze            │  │  │
│  │  │ - named_entities │  │ - llm_summarize          │  │  │
│  │  │ - text_summarizer│  │ - llm_classify           │  │  │
│  │  └─────────────────┘  │ - llm_qa                 │  │  │
│  │                        │ - llm_generate           │  │  │
│  │                        │ - llm_chain              │  │  │
│  │                        └──────────────────────────┘  │  │
│  └──────────────────────────────────────────────────────┘  │
│                                 │                            │
│                                 ▼                            │
│  ┌──────────────────────────────────────────────────────┐  │
│  │           LangChain Integration Layer                 │  │
│  │                                                        │  │
│  │  ┌───────────────┐  ┌───────────────┐  ┌──────────┐ │  │
│  │  │ Prompt        │  │ LLM Providers │  │ Output   │ │  │
│  │  │ Templates     │  │ - OpenAI      │  │ Parsers  │ │  │
│  │  │               │  │ - Anthropic   │  │          │ │  │
│  │  │               │  │ - Local       │  │          │ │  │
│  │  └───────────────┘  └───────────────┘  └──────────┘ │  │
│  └──────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

### Core Components

#### 1. LLM Function Registry

Add LLM-specific functions to the compute function registry:

```python
# In lynguine/assess/llm.py (new module)

from langchain.llms import OpenAI, Anthropic
from langchain.chat_models import ChatOpenAI, ChatAnthropic
from langchain.prompts import PromptTemplate, ChatPromptTemplate
from langchain.chains import LLMChain
from langchain.output_parsers import JSONOutputParser, PydanticOutputParser

class LLMComputeFunctions:
    """LLM-based compute functions using LangChain."""
    
    def __init__(self, default_provider='openai', api_keys=None):
        self.default_provider = default_provider
        self.api_keys = api_keys or {}
        self._llm_cache = {}
    
    def get_llm(self, provider, model, **kwargs):
        """Get or create LLM instance with caching."""
        cache_key = (provider, model, frozenset(kwargs.items()))
        if cache_key not in self._llm_cache:
            if provider == 'openai':
                self._llm_cache[cache_key] = ChatOpenAI(
                    model_name=model,
                    openai_api_key=self.api_keys.get('openai'),
                    **kwargs
                )
            elif provider == 'anthropic':
                self._llm_cache[cache_key] = ChatAnthropic(
                    model=model,
                    anthropic_api_key=self.api_keys.get('anthropic'),
                    **kwargs
                )
            # Add more providers as needed
        return self._llm_cache[cache_key]
    
    def llm_analyze(self, text, prompt, model='gpt-3.5-turbo', 
                   provider=None, temperature=0.0, max_tokens=None, **kwargs):
        """Analyze text using LLM with custom prompt."""
        provider = provider or self.default_provider
        llm = self.get_llm(provider, model, temperature=temperature)
        
        prompt_template = PromptTemplate(
            input_variables=["text"],
            template=prompt + "\n\nText: {text}"
        )
        
        chain = LLMChain(llm=llm, prompt=prompt_template)
        result = chain.run(text=text)
        return result
    
    def llm_summarize(self, text, max_length=150, model='gpt-3.5-turbo',
                     provider=None, context=None, **kwargs):
        """Summarize text using LLM."""
        provider = provider or self.default_provider
        llm = self.get_llm(provider, model, temperature=0.0)
        
        if context:
            prompt_template = PromptTemplate(
                input_variables=["text", "context"],
                template="Given this context:\n{context}\n\nSummarize the following text in {max_length} words or less:\n{text}"
            )
            chain = LLMChain(llm=llm, prompt=prompt_template)
            result = chain.run(text=text, context=context, max_length=max_length)
        else:
            prompt_template = PromptTemplate(
                input_variables=["text", "max_length"],
                template="Summarize the following text in {max_length} words or less:\n{text}"
            )
            chain = LLMChain(llm=llm, prompt=prompt_template)
            result = chain.run(text=text, max_length=max_length)
        
        return result
    
    def llm_classify(self, text, categories, model='gpt-3.5-turbo',
                    provider=None, output_format='json', **kwargs):
        """Classify text into categories using LLM."""
        provider = provider or self.default_provider
        llm = self.get_llm(provider, model, temperature=0.0)
        
        if output_format == 'json':
            parser = JSONOutputParser()
            format_instructions = parser.get_format_instructions()
        else:
            format_instructions = ""
        
        prompt_template = PromptTemplate(
            input_variables=["text", "categories"],
            template="""Classify the following text into these categories: {categories}

{format_instructions}

Text: {text}""",
            partial_variables={"format_instructions": format_instructions}
        )
        
        chain = LLMChain(llm=llm, prompt=prompt_template)
        result = chain.run(text=text, categories=", ".join(categories))
        
        if output_format == 'json':
            try:
                return parser.parse(result)
            except:
                return result
        return result
    
    def llm_qa(self, context, question, model='gpt-3.5-turbo',
              provider=None, **kwargs):
        """Answer questions about text using LLM."""
        provider = provider or self.default_provider
        llm = self.get_llm(provider, model, temperature=0.0)
        
        prompt_template = PromptTemplate(
            input_variables=["context", "question"],
            template="""Context: {context}

Question: {question}

Answer:"""
        )
        
        chain = LLMChain(llm=llm, prompt=prompt_template)
        result = chain.run(context=context, question=question)
        return result
    
    def llm_sentiment(self, text, aspects=None, model='gpt-3.5-turbo',
                     provider=None, **kwargs):
        """Analyze sentiment and tone of text."""
        provider = provider or self.default_provider
        llm = self.get_llm(provider, model, temperature=0.0)
        
        if aspects:
            aspect_str = ", ".join(aspects)
            prompt = f"""Analyze the sentiment and tone of the following text for these aspects: {aspect_str}

Return your analysis as a JSON object with each aspect rated on a scale of 1-5.

Text: {{text}}"""
        else:
            prompt = """Analyze the overall sentiment and tone of the following text.

Return: positive, negative, or neutral

Text: {text}"""
        
        prompt_template = PromptTemplate(
            input_variables=["text"],
            template=prompt
        )
        
        chain = LLMChain(llm=llm, prompt=prompt_template)
        result = chain.run(text=text)
        
        if aspects:
            try:
                parser = JSONOutputParser()
                return parser.parse(result)
            except:
                return result
        return result
    
    def llm_generate(self, prompt, model='gpt-3.5-turbo', provider=None,
                    temperature=0.7, max_tokens=None, **kwargs):
        """Generate text using LLM with custom prompt."""
        provider = provider or self.default_provider
        llm = self.get_llm(provider, model, temperature=temperature,
                          max_tokens=max_tokens)
        
        prompt_template = PromptTemplate(
            input_variables=[],
            template=prompt
        )
        
        chain = LLMChain(llm=llm, prompt=prompt_template)
        result = chain.run({})
        return result
    
    def llm_chain(self, text, chain_spec, model='gpt-3.5-turbo',
                 provider=None, **kwargs):
        """Execute a chain of LLM operations."""
        provider = provider or self.default_provider
        llm = self.get_llm(provider, model)
        
        # Implementation for chained LLM operations
        # This would support sequential LLM calls with intermediate results
        pass
```

#### 2. Integration with Compute Class

Extend the compute class to include LLM functions:

```python
# In lynguine/assess/compute.py

from .llm import LLMComputeFunctions

class Compute():
    def __init__(self, interface):
        super().__init__(interface)
        
        # Initialize LLM functions if API keys are provided
        llm_config = interface.get('llm', {})
        if llm_config:
            self._llm_functions = LLMComputeFunctions(
                default_provider=llm_config.get('default_provider', 'openai'),
                api_keys=llm_config.get('api_keys', {})
            )
        else:
            self._llm_functions = None
    
    def _compute_functions_list(self):
        base_functions = super()._compute_functions_list()
        
        if self._llm_functions:
            llm_functions = [
                {
                    "name": "llm_analyze",
                    "function": self._llm_functions.llm_analyze,
                    "default_args": {
                        "model": "gpt-3.5-turbo",
                        "temperature": 0.0,
                    },
                    "docstr": "Analyze text using LLM with custom prompt.",
                },
                {
                    "name": "llm_summarize",
                    "function": self._llm_functions.llm_summarize,
                    "default_args": {
                        "max_length": 150,
                        "model": "gpt-3.5-turbo",
                    },
                    "docstr": "Summarize text using LLM.",
                },
                {
                    "name": "llm_classify",
                    "function": self._llm_functions.llm_classify,
                    "default_args": {
                        "model": "gpt-3.5-turbo",
                        "output_format": "json",
                    },
                    "docstr": "Classify text into categories using LLM.",
                },
                {
                    "name": "llm_qa",
                    "function": self._llm_functions.llm_qa,
                    "default_args": {
                        "model": "gpt-3.5-turbo",
                    },
                    "docstr": "Answer questions about text using LLM.",
                },
                {
                    "name": "llm_sentiment",
                    "function": self._llm_functions.llm_sentiment,
                    "default_args": {
                        "model": "gpt-3.5-turbo",
                    },
                    "docstr": "Analyze sentiment and tone of text.",
                },
                {
                    "name": "llm_generate",
                    "function": self._llm_functions.llm_generate,
                    "default_args": {
                        "model": "gpt-3.5-turbo",
                        "temperature": 0.7,
                    },
                    "docstr": "Generate text using LLM with custom prompt.",
                },
            ]
            return base_functions + llm_functions
        
        return base_functions
```

#### 3. Configuration Format

Users can configure LLM integration in their YAML files:

```yaml
# Configuration section for LLM setup
llm:
  default_provider: openai
  api_keys:
    openai: ${OPENAI_API_KEY}  # Environment variable
    anthropic: ${ANTHROPIC_API_KEY}
  cache_dir: .llm_cache
  rate_limit:
    requests_per_minute: 50

# Using LLM functions in compute
compute:
  - function: llm_analyze
    field: quality_assessment
    row_args:
      text: review_text
    args:
      prompt: |
        Analyze this peer review for quality metrics.
        Rate on a scale of 1-5:
        - Constructiveness
        - Technical depth
        - Clarity
        - Actionability
        Return as JSON.
      model: gpt-4
      output_format: json
  
  - function: llm_summarize
    field: executive_summary
    row_args:
      text: review_text
    args:
      max_length: 100
      model: gpt-3.5-turbo
  
  - function: llm_classify
    field: review_categories
    row_args:
      text: review_text
    args:
      categories:
        - methodology
        - results
        - writing
        - significance
      output_format: json
```

### Error Handling and Fallbacks

```python
class LLMComputeFunctions:
    def __init__(self, default_provider='openai', api_keys=None, 
                 fallback_provider=None, retry_config=None):
        self.default_provider = default_provider
        self.fallback_provider = fallback_provider
        self.api_keys = api_keys or {}
        self.retry_config = retry_config or {'max_retries': 3, 'backoff': 2}
    
    def _execute_with_fallback(self, func, *args, **kwargs):
        """Execute LLM function with automatic fallback."""
        try:
            return func(*args, **kwargs)
        except Exception as e:
            self.logger.warning(f"Primary LLM call failed: {e}")
            if self.fallback_provider:
                self.logger.info(f"Trying fallback provider: {self.fallback_provider}")
                # Retry with fallback provider
                kwargs['provider'] = self.fallback_provider
                return func(*args, **kwargs)
            raise
```

### Caching Strategy

```python
from functools import lru_cache
import hashlib
import json

class LLMComputeFunctions:
    def __init__(self, cache_dir=None, **kwargs):
        self.cache_dir = cache_dir
        if cache_dir:
            os.makedirs(cache_dir, exist_ok=True)
    
    def _cache_key(self, function_name, **kwargs):
        """Generate cache key from function and arguments."""
        cache_data = json.dumps(kwargs, sort_keys=True)
        return hashlib.md5(f"{function_name}:{cache_data}".encode()).hexdigest()
    
    def _get_cached_result(self, cache_key):
        """Retrieve cached LLM result if available."""
        if not self.cache_dir:
            return None
        cache_file = os.path.join(self.cache_dir, f"{cache_key}.json")
        if os.path.exists(cache_file):
            with open(cache_file, 'r') as f:
                return json.load(f)['result']
        return None
    
    def _cache_result(self, cache_key, result):
        """Cache LLM result for future use."""
        if not self.cache_dir:
            return
        cache_file = os.path.join(self.cache_dir, f"{cache_key}.json")
        with open(cache_file, 'w') as f:
            json.dump({'result': result, 'timestamp': datetime.now().isoformat()}, f)
```

## Implementation Plan (Extraction from Referia)

### Phase 1: Preparation and Analysis (Week 1)
- [x] Analyze referia CIP-0006 implementation
- [x] Create extraction analysis document (`cip0004_referia_analysis.md`)
- [x] Identify generic vs domain-specific components
- [ ] Review extraction plan with stakeholders
- [ ] Create detailed component mapping

### Phase 2: Extract Core Infrastructure (Week 1-2)
- [ ] Create `lynguine/util/llm.py` from `referia/util/llm.py`
- [ ] Extract `LLMManager` class (~350 lines)
- [ ] Extract `CostTracker` class
- [ ] Extract exception classes (LLMError, LLMConfigError, etc.)
- [ ] Remove referia-specific dependencies
- [ ] Add to `lynguine/util/__init__.py`

### Phase 3: Extract Generic Compute Functions (Week 2)
- [ ] Add generic LLM functions to `lynguine/assess/compute.py`:
  - [ ] `llm_complete` - General completion
  - [ ] `llm_chat` - Chat interface
  - [ ] `llm_summarise` - Text summarization
  - [ ] `llm_extract` - Information extraction
  - [ ] `llm_classify` - Text classification
- [ ] Register in base Compute class function registry
- [ ] Ensure optional loading (graceful degradation)

### Phase 4: Configuration and Dependencies (Week 2-3)
- [ ] Add LLM config section to `lynguine/config/interface.py`
- [ ] Add LangChain dependencies to `pyproject.toml` as optional extras
- [ ] Update dependency documentation
- [ ] Test installation with/without LLM extras

### Phase 5: Testing (Week 3)
- [ ] Port tests from `referia/tests/test_llm_integration.py`
- [ ] Adapt tests for lynguine context
- [ ] Add lynguine-specific test cases
- [ ] Test graceful degradation (without LLM dependencies)
- [ ] Verify no referia dependencies in tests
- [ ] Target: 10+ tests, all passing

### Phase 6: Documentation (Week 3-4)
- [ ] Create `docs/llm_integration.md` (adapt from referia)
- [ ] Update `docs/compute_framework.md` with LLM functions
- [ ] API documentation for LLM classes and functions
- [ ] Add examples to README
- [ ] Create quickstart guide
- [ ] Document optional dependency installation

### Phase 7: Referia Integration (Week 4)
- [ ] Update referia to import from lynguine:
  - [ ] `from lynguine.util.llm import LLMManager, get_llm_manager`
  - [ ] Remove duplicated generic functions from referia
  - [ ] Keep domain-specific functions (llm_pdf_review, etc.)
- [ ] Update referia tests
- [ ] Verify all referia tests still pass
- [ ] Update referia documentation

### Phase 8: Validation and Release (Week 4-5)
- [ ] Code review
- [ ] Performance comparison (before/after extraction)
- [ ] Security review (API key handling, etc.)
- [ ] Update CHANGELOG
- [ ] Create migration guide for applications
- [ ] Tag release

**Estimated Timeline**: 4-5 weeks (reduced from original 7-8 weeks because code already exists)

## Backward Compatibility

### Compatibility Considerations

1. **Optional Dependency**: LangChain and LLM support will be optional
   - Core functionality works without LLM dependencies
   - LLM functions only registered if dependencies are installed
   - Clear error messages if LLM functions used without setup

2. **Configuration**: Existing configurations will continue to work
   - New `llm:` section is optional
   - No breaking changes to existing compute specifications
   - LLM functions are additive to existing function registry

3. **Migration Path**: Users can adopt incrementally
   - Start with simple LLM functions alongside existing ones
   - Gradually migrate complex text processing to LLMs
   - Keep existing text processing functions as fallbacks

### Installation Options

```bash
# Minimal installation (no LLM support)
pip install lynguine

# Full installation with LLM support
pip install lynguine[llm]

# Or via poetry
poetry install --extras llm
```

## Testing Strategy

### Unit Tests
```python
# tests/test_llm.py

def test_llm_analyze_with_mock():
    """Test LLM analyze function with mocked responses."""
    llm_funcs = LLMComputeFunctions()
    with patch('langchain.llms.OpenAI') as mock_llm:
        mock_llm.return_value.predict.return_value = "Analysis result"
        result = llm_funcs.llm_analyze(
            text="Test text",
            prompt="Analyze this"
        )
        assert result == "Analysis result"

def test_llm_caching():
    """Test that LLM results are properly cached."""
    llm_funcs = LLMComputeFunctions(cache_dir=".test_cache")
    # First call
    result1 = llm_funcs.llm_summarize(text="Long text here")
    # Second call should use cache
    result2 = llm_funcs.llm_summarize(text="Long text here")
    assert result1 == result2
```

### Integration Tests
```python
# tests/test_llm_integration.py

def test_llm_in_compute_pipeline():
    """Test LLM functions work in full compute pipeline."""
    config = {
        'llm': {
            'default_provider': 'openai',
            'api_keys': {'openai': 'test-key'}
        },
        'compute': [
            {
                'function': 'llm_summarize',
                'field': 'summary',
                'row_args': {'text': 'review_text'},
                'args': {'max_length': 100}
            }
        ]
    }
    
    interface = Interface(config)
    compute = Compute(interface)
    data = CustomDataFrame({'review_text': ['Long review text...']})
    
    compute.run_all(data, interface)
    assert 'summary' in data.columns
```

### End-to-End Tests
- Real LLM calls with test API keys
- Performance benchmarks
- Cost tracking validation
- Error handling scenarios

## Security and Privacy Considerations

### API Key Management
- Never store API keys in configuration files
- Use environment variables or secure vaults
- Support for encrypted configuration files
- Audit logging for LLM calls

### Data Privacy
- Option to disable LLM functions for sensitive data
- Support for local/on-premise models
- Clear documentation on data sent to external APIs
- Option to anonymize data before LLM processing

### Cost Management
- Built-in cost tracking for API calls
- Configurable spending limits
- Warning system for high-cost operations
- Batch processing optimizations

## Performance Considerations

### Optimization Strategies

1. **Caching**: Cache LLM responses for repeated queries
2. **Batching**: Batch multiple LLM calls when possible
3. **Async Execution**: Support async LLM calls for better throughput
4. **Model Selection**: Allow model selection based on task complexity
5. **Rate Limiting**: Respect API rate limits automatically

### Performance Targets

- Single LLM call: < 5 seconds (depends on model)
- Cached response retrieval: < 100ms
- Batch processing: Support 100+ rows efficiently
- Memory usage: Minimal overhead beyond LangChain requirements

## Documentation Requirements

### User Documentation
- [ ] Quick start guide for LLM integration
- [ ] Configuration reference
- [ ] Function reference for each LLM function
- [ ] Example use cases and recipes
- [ ] Best practices guide
- [ ] Troubleshooting guide

### Developer Documentation
- [ ] Architecture overview
- [ ] Adding new LLM providers
- [ ] Extending LLM functions
- [ ] Testing guide
- [ ] Contributing guidelines

## Dependencies

### New Dependencies
```toml
[tool.poetry.dependencies]
# Existing dependencies...

# LLM support (optional)
langchain = { version = "^0.1.0", optional = true }
openai = { version = "^1.0.0", optional = true }
anthropic = { version = "^0.8.0", optional = true }
tiktoken = { version = "^0.5.0", optional = true }

[tool.poetry.extras]
llm = ["langchain", "openai", "anthropic", "tiktoken"]
```

### Version Compatibility
- Python >= 3.9 (for LangChain)
- LangChain >= 0.1.0
- OpenAI >= 1.0.0
- Anthropic >= 0.8.0

## Future Enhancements

### Planned for Future CIPs

1. **Vector Database Integration**: Support for embeddings and semantic search
2. **RAG (Retrieval-Augmented Generation)**: Integration with document stores
3. **Fine-tuning Support**: Train custom models on review data
4. **Multi-modal Support**: Process images, PDFs, audio
5. **Agent Support**: LLM agents for complex workflows
6. **Prompt Library**: Curated prompts for common tasks
7. **A/B Testing**: Compare different LLM providers/models
8. **Monitoring Dashboard**: Real-time LLM usage and cost tracking

## Alternative Approaches Considered

### 1. Direct API Integration (Without LangChain)
**Pros**: Simpler, fewer dependencies
**Cons**: More code to maintain, less flexible, no chain support
**Decision**: LangChain provides better abstraction and features

### 2. OpenAI-Only Integration
**Pros**: Simpler implementation
**Cons**: Vendor lock-in, less flexibility
**Decision**: Multi-provider support via LangChain is more valuable

### 3. Separate LLM Service
**Pros**: Better separation of concerns
**Cons**: More complex deployment, network overhead
**Decision**: Direct integration is simpler for most users

## Risks and Mitigation

### Risk 1: Cost Overruns
**Mitigation**: 
- Built-in cost tracking and limits
- Caching to reduce redundant calls
- Documentation on cost-effective usage

### Risk 2: API Rate Limiting
**Mitigation**:
- Automatic rate limiting and backoff
- Support for multiple API keys (rotation)
- Batch processing optimizations

### Risk 3: Response Quality Variability
**Mitigation**:
- Temperature=0 for deterministic tasks
- Few-shot examples in prompts
- Output validation and retry logic
- Option to use multiple models for comparison

### Risk 4: Dependency Complexity
**Mitigation**:
- Optional installation (`pip install lynguine[llm]`)
- Clear documentation on setup
- Good error messages when dependencies missing

### Risk 5: Privacy and Security
**Mitigation**:
- Support for local models
- Clear data handling documentation
- Optional anonymization
- Audit logging

## Success Metrics

- [ ] 90%+ test coverage for LLM module
- [ ] < 5 seconds average response time for typical LLM calls
- [ ] < 100ms cache hit response time
- [ ] Support for at least 3 LLM providers
- [ ] Comprehensive documentation (>50 pages)
- [ ] 10+ example use cases
- [ ] Positive user feedback from beta testers

## References

- [LangChain Documentation](https://python.langchain.com/)
- [OpenAI API Documentation](https://platform.openai.com/docs/)
- [Anthropic Claude Documentation](https://docs.anthropic.com/)
- [Prompt Engineering Guide](https://www.promptingguide.ai/)
- [Compute Framework Documentation](../docs/compute_framework.md)

## Related CIPs

- CIP-0005: Vector Database Integration (Future)
- CIP-0006: RAG Implementation (Future)

## Referia Implementation Reference (CIP-0006)

For detailed reference, see referia's working implementation:

### Files in Referia
- **Core**: `referia/util/llm.py` (494 lines) - LLMManager, CostTracker, exceptions
- **Functions**: `referia/assess/compute.py` - 7 LLM compute functions
- **Tests**: `referia/tests/test_llm_integration.py` - 16 tests (all passing)
- **Tests**: `referia/tests/test_llm_include_query.py` - Additional integration tests
- **Docs**: `referia/docs/llm_integration.md` - User guide
- **Docs**: `referia/docs/llm_pdf_review.md` - PDF review documentation
- **Examples**: `referia/examples/llm_integration_example.yml` - Configuration examples
- **Examples**: `referia/examples/thesis_llm_review_example.{yml,py}` - Real-world usage

### What's Working in Referia (Status: Implemented)
✅ **Infrastructure**:
- LLMManager with OpenAI and Anthropic support
- Cost tracking with budget enforcement (8 model pricings)
- Automatic retry with exponential backoff
- Response caching with TTL
- .env file support for API keys
- Graceful degradation without LLM dependencies

✅ **Compute Functions**:
1. `llm_complete` - General-purpose completion
2. `llm_summarise` - Text summarization
3. `llm_extract` - Structured information extraction
4. `llm_classify` - Text classification
5. `llm_chat` - Chat-style interaction with context
6. `llm_pdf_review` - PDF extraction and review (6 types: general, strengths, weaknesses, technical, summary, questions)
7. `llm_custom_query` - Custom prompts on PDF sections

✅ **Testing**: 16 tests, all passing, with/without LLM dependencies

✅ **Production Use**: Successfully used in referia assessment workflows

### Components to Extract to Lynguine

**Generic (extract to lynguine)**:
- `LLMManager` class (full implementation)
- `CostTracker` class (full implementation)
- Exception classes (all 4)
- Functions: `llm_complete`, `llm_chat`, `llm_summarise`, `llm_extract`, `llm_classify`
- Configuration schema
- Generic tests and documentation

**Domain-Specific (stay in referia)**:
- `llm_pdf_review` function (review-specific prompts)
- `llm_custom_query` function (PDF-specific)
- Assessment workflow integrations
- Review-specific prompt templates

## Changelog

- 2025-12-21: Updated with referia implementation analysis, changed to extraction CIP
- 2025-11-06: Initial proposal created

