---
author: Neil Lawrence
created: '2025-12-24'
effort: large
id: '0007'
last_updated: '2025-12-24'
priority: high
status: Proposed
tags:
- cip
- architecture
- refactoring
- separation-of-concerns
- vongole
title: Separate Storage and Compute Primitives into Distinct Packages
type: architecture
---

# CIP-0007: Separate Storage and Compute Primitives into Distinct Packages

## Summary

Split lynguine into two distinct packages: **lynguine** (storage/access primitives + access-level compute) and **vongole** (assessment-level compute primitives). This architectural change will create clearer separation of concerns, make dependencies explicit, and better align with Data Oriented Architecture (DOA) principles and the access-assess-address pattern.

**Key Insight**: Not all compute can be separated from storage. Basic data access requires compute operations like template rendering (e.g., `{{familyName}}_{{givenName}}` for indices), path resolution, and column mapping. This CIP distinguishes between:
- **Access Compute** (stays in lynguine): Lightweight operations needed to load and structure data
- **Assessment Compute** (moves to vongole): Heavy transformations and analysis on structured data

## Motivation

### The Reality of "Access Compute" vs "Assessment Compute"

**Important Recognition**: Not all compute can be separated from storage. Accessing data inherently requires some computation:

- **Index Construction**: Patterns like `{{familyName}}_{{givenName}}` require template rendering
- **Path Resolution**: Filename patterns and directory traversal
- **Column Mapping**: Transforming column names during load
- **Type Inference**: Converting strings to appropriate data types
- **Pattern Matching**: Finding files based on regex or glob patterns

**The key insight**: There are two types of compute:
1. **Access Compute** (intrinsic to data loading): Template rendering, path construction, basic transformations needed to access and structure data
2. **Assessment Compute** (transformations on structured data): Analytics, aggregations, complex transformations, NLP, custom functions

**This CIP proposes separating assessment compute, while keeping access compute in lynguine.**

### Current Architecture Issues

Currently, lynguine merges storage, access compute, AND assessment compute capabilities:

```
lynguine/
â”œâ”€â”€ access/          # Storage/data loading
â”‚   â”œâ”€â”€ io.py
â”‚   â””â”€â”€ download.py
â”œâ”€â”€ assess/          # Data structures + compute (mixed)
â”‚   â”œâ”€â”€ data.py      # CustomDataFrame
â”‚   â”œâ”€â”€ compute.py   # Compute engine
â”‚   â””â”€â”€ display.py
â”œâ”€â”€ config/          # Configuration
â”‚   â”œâ”€â”€ interface.py
â”‚   â””â”€â”€ context.py
â””â”€â”€ security/        # Credential management
```

**Problems**:
1. **Unclear boundaries**: Access compute and assessment compute are mixed together
2. **Dependency confusion**: Hard to understand what's required for basic access vs advanced transformation
3. **Violates tenets**: Doesn't make data flows explicit (access vs assess)
4. **Reusability**: Can't do basic data access without pulling in heavy dependencies (spaCy, NLP libraries)
5. **Testing complexity**: Hard to test access independently of assessment transformations

### Alignment with Project Tenets

#### Explicit Infrastructure Tenet

From `tenets/lynguine/explicit-infrastructure.md`:
> "lynguine is a Data Oriented Architecture (DOA) infrastructure library that should be explicit, machine-understandable, and predictable."

**Current state**: Compute and storage are implicitly mixed
**Proposed state**: Explicit separation with clear dependency boundaries

#### Flow-Based Processing Tenet

From `tenets/lynguine/flow-based-processing.md`:
> "lynguine implements flow-based data processing where data moves through explicit stages and transformations. All processing should follow the access-assess-address pattern."

**The access-assess-address pattern suggests three distinct stages**:
- **Access** (lynguine): Load and structure data
- **Assess** (vongole): Compute and transform data
- **Address** (future): Output and presentation

Currently, "assess" is split between data structures (should be in access) and compute operations (should be separate).

### Benefits of Separation

1. **Clearer architecture**: Each package has a single, well-defined purpose
2. **Better dependency management**: Applications can depend on only what they need
3. **Improved testability**: Test storage and compute independently
4. **Extensibility**: Easier to create alternative compute engines
5. **Alignment with DOA**: Separates data structures from operations on data
6. **Better documentation**: Each package can have focused documentation
7. **Parallel development**: Teams can work on storage and compute independently

## Detailed Description

### Proposed Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Application Layer                        â”‚
â”‚                  (referia, lamd, etc.)                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚                            â”‚
                 â–¼                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      lynguine              â”‚   â”‚      vongole             â”‚
â”‚   (Storage + Access)       â”‚â—„â”€â”€â”‚  (Assessment Compute)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ access/                  â”‚   â”‚ â€¢ Compute (extends       â”‚
â”‚   - io.py                  â”‚   â”‚   lynguine.Compute)      â”‚
â”‚   - download.py            â”‚   â”‚ â€¢ functions/             â”‚
â”‚ â€¢ assess/                  â”‚   â”‚   - text.py (NLP)        â”‚
â”‚   - data.py (DataFrames)   â”‚   â”‚   - dataframe.py (agg)   â”‚
â”‚   - display.py             â”‚   â”‚   - files.py (PDF)       â”‚
â”‚   - compute.py âœ¨          â”‚   â”‚   - visualization.py     â”‚
â”‚     * Base compute engine  â”‚   â”‚                          â”‚
â”‚     * Function registry    â”‚   â”‚ Inheritance:             â”‚
â”‚     * Argument resolution  â”‚   â”‚   lynguine.Compute       â”‚
â”‚     * Access functions     â”‚   â”‚        â†‘                 â”‚
â”‚ â€¢ config/                  â”‚   â”‚        â””â”€â”€ vongole       â”‚
â”‚   - interface.py           â”‚   â”‚                          â”‚
â”‚   - context.py             â”‚   â”‚ Dependencies:            â”‚
â”‚ â€¢ security/                â”‚   â”‚ â€¢ lynguine (base class)  â”‚
â”‚ â€¢ util/                    â”‚   â”‚ â€¢ spaCy (optional)       â”‚
â”‚   - liquid.py              â”‚   â”‚ â€¢ matplotlib (optional)  â”‚
â”‚   - text.py (basic)        â”‚   â”‚                          â”‚
â”‚                            â”‚   â”‚                          â”‚
â”‚ âœ¨ = Base Compute Engine   â”‚   â”‚                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Compute Inheritance Pattern:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  lynguine.assess.compute.Compute (base engine)           â”‚
â”‚  â€¢ Core compute infrastructure                           â”‚
â”‚  â€¢ Function registry system                              â”‚
â”‚  â€¢ Argument resolution (row_args, column_args, etc.)     â”‚
â”‚  â€¢ Three-phase processing                                â”‚
â”‚  â€¢ Access-level functions (render_liquid, today, etc.)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚ inherits & extends
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  vongole.Compute                                         â”‚
â”‚  â€¢ Inherits all base functionality                       â”‚
â”‚  â€¢ Extends function registry with assessment functions   â”‚
â”‚  â€¢ Adds: NLP, aggregations, visualizations, etc.         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚ inherits & extends (optional)
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  referia.assess.compute.Compute                          â”‚
â”‚  â€¢ Inherits vongole (or lynguine if not using vongole)  â”‚
â”‚  â€¢ Adds application-specific compute functions           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Package Responsibilities

#### lynguine (Storage/Access + Base Compute Engine)

**Purpose**: Data access, loading, structure management, and **base compute infrastructure with access-level functions**

**Contains**:
- `access/` - Data loading from various sources (CSV, Excel, YAML, Google Sheets, etc.)
- `assess/data.py` - Data structures (`CustomDataFrame`, `DataObject`)
- `assess/compute.py` - **Base Compute engine** with access-level functions
- `assess/display.py` - Display/visualization (if compute-independent)
- `config/` - Configuration management (`Interface`, `Context`)
- `security/` - Credential management
- `util/` - Utilities for access-level operations:
  - `liquid.py` - Template rendering
  - `files.py` - File operations
  - `yaml.py` - YAML processing
  - `html.py` - HTML utilities
  - `text.py` - Basic string operations
  - `misc.py` - General utilities

**Base Compute Engine** (stays in lynguine):
- **Core Infrastructure**:
  - Function registry system
  - Argument resolution (row_args, column_args, subseries_args, view_args, function_args)
  - Three-phase processing (precompute, compute, postcompute)
  - Cache management
  - Refresh logic

- **Access-Level Functions**:
  - `render_liquid()` - Template rendering for indices, paths
  - `today()` - Current date for timestamps
  - Basic string formatting functions
  - Pattern matching utilities

**Why the compute engine stays in lynguine**:
- Access compute (index construction, path resolution) needs the compute infrastructure
- The engine itself is lightweight - it's the function library that's heavy
- Makes vongole simpler - just extends the function registry
- Maintains existing inheritance pattern (like referia)

**Key APIs**:
```python
from lynguine import Interface, Context
from lynguine.access import read_data
from lynguine.assess.data import CustomDataFrame
from lynguine.assess.compute import Compute  # Base engine with access functions
from lynguine.util.liquid import render_liquid
```

**Dependencies**:
- pandas
- PyYAML
- liquid (for template rendering)
- cryptography (optional, for security)
- google-api-python-client (optional, for Google Sheets)

#### vongole (Assessment Compute - Extends lynguine.Compute)

**Purpose**: Extend base compute engine with **assessment-level functions**

**Contains**:
- `compute.py` - **Extends `lynguine.assess.compute.Compute`**
- `functions/` - Assessment-level function implementations
  - `text.py` - **Advanced text processing** (word count, summarization, NLP)
  - `dataframe.py` - **DataFrame transformations** (aggregations, filtering, sorting)
  - `files.py` - **File content operations** (PDF extraction, document analysis)
  - `datetime.py` - **Date/time computations** (date arithmetic, formatting)
  - `visualization.py` - **Plotting and visualization** (histograms, charts)

**Architecture Pattern**:
```python
class Compute(lynguine.assess.compute.Compute):
    """
    Extends lynguine's base compute engine with assessment-level functions.
    Inherits all infrastructure (registry, argument resolution, phases).
    """
    
    def _compute_functions_list(self):
        # Get base functions from lynguine
        base_functions = super()._compute_functions_list()
        
        # Add assessment-level functions
        assessment_functions = [
            {
                "name": "word_count",
                "function": word_count,
                "default_args": {},
                "docstr": "Count words in text"
            },
            # ... more assessment functions
        ]
        
        return base_functions + assessment_functions
```

**Assessment-Level Functions** (added by vongole):
- **Text analysis**: Word count, NLP, entity extraction, summarization
- **Aggregations**: Cross-row statistics, grouping, pivoting
- **Complex transformations**: Custom functions on structured data
- **File content processing**: PDF parsing, document analysis
- **Visualization**: Histograms, plots, charts
- **Subseries operations**: Filtering, selecting, transforming subsets

**Key APIs**:
```python
from vongole import Compute  # Extends lynguine.assess.compute.Compute
from vongole.functions import register_function

# The compute engine works exactly like lynguine's, but with more functions
compute = Compute(interface)
compute.run_all(data, interface)
```

**Dependencies**:
- lynguine (inherits base Compute class, uses Interface, Context, CustomDataFrame)
- pandas (already in lynguine)
- spacy (optional, for NLP functions)
- matplotlib/plotly (optional, for visualization)

**Why this is simpler**:
- No need to reimplement compute engine infrastructure
- Just extends the function registry
- Maintains compatibility with existing inheritance patterns
- vongole can be a thin layer of functions over lynguine's engine

### Dependency Relationship

**Direction**: vongole depends on lynguine (not vice versa)

```
lynguine (base layer, no compute dependencies)
    â†‘
    â”‚ depends on
    â”‚
vongole (compute layer, depends on lynguine for data structures)
    â†‘
    â”‚ depends on both
    â”‚
applications (referia, lamd, etc.)
```

**Rationale**:
- Storage is more fundamental than compute
- Compute needs data structures, but data structures don't need compute
- Applications typically need both, so they import both
- Some applications might only need storage (e.g., simple data loaders)

### The Access/Assessment Compute Boundary

**Key Principle**: The boundary is about **when** the compute happens and **what it's for**, not just **what** the compute does.

#### Access Compute (lynguine)
**When**: During data loading and structuring
**Purpose**: Make data accessible and properly structured
**Characteristics**:
- Required for basic data access
- Runs during `read_data()`, `from_flow()`, etc.
- Creates indices, resolves paths, maps columns
- Lightweight dependencies (liquid templates, basic string ops)

**Examples**:
```yaml
# Index construction using templates
input:
  type: csv
  index: "{{familyName}}_{{givenName}}"  # â† Access compute
  
# Path resolution
input:
  type: csv
  filename: "data/{{year}}/{{month}}.csv"  # â† Access compute
  
# Column mapping during load
input:
  type: excel
  rename_columns:
    "First Name": "givenName"  # â† Access compute
```

**Functions needed in lynguine**:
- `render_liquid()` - Template rendering
- String formatting and manipulation
- Pattern matching (regex, glob)
- Basic type conversion during load
- Column name transformations

#### Assessment Compute (vongole)
**When**: After data is loaded and structured
**Purpose**: Transform, analyze, and compute on structured data
**Characteristics**:
- Optional for basic data access
- Runs during explicit compute phase
- Operates on structured DataFrames
- Heavy dependencies (spaCy, plotting libraries)

**Examples**:
```yaml
# Text analysis on loaded data
compute:
  - function: word_count  # â† Assessment compute
    field: review_word_count
    row_args:
      text: review_text

# Aggregations across rows
compute:
  - function: sum  # â† Assessment compute
    field: total_score
    column_args:
      values: individual_scores

# Complex transformations
compute:
  - function: named_entities  # â† Assessment compute (requires spaCy)
    field: entities
    row_args:
      text: document
```

**Functions needed in vongole**:
- Word count, text summarization, NLP
- Statistical aggregations
- PDF content extraction
- Visualization
- Complex DataFrame manipulations

#### Real-World Example

```yaml
# Configuration showing both types of compute

input:
  type: csv
  filename: "reviews/{{year}}/reviews.csv"  # â† lynguine (access compute)
  index: "{{reviewer_id}}_{{date}}"          # â† lynguine (access compute)
  rename_columns:                            # â† lynguine (access compute)
    "Review Text": "review_text"
    "Reviewer Name": "reviewer_name"

compute:                                     # â† vongole (assessment compute)
  - function: word_count
    field: word_count
    row_args:
      text: review_text
  
  - function: text_summarizer
    field: summary
    row_args:
      text: review_text
```

**In this example**:
- **lynguine** handles: Finding the file, constructing indices, mapping column names
- **vongole** handles: Counting words, generating summaries

### Migration of Components

#### Stays in lynguine (Base Layer)

**Core Infrastructure**:
- âœ… `access/io.py` - Data loading
- âœ… `access/download.py` - File retrieval
- âœ… `assess/data.py` - `CustomDataFrame`, `DataObject`
- âœ… `assess/compute.py` - **Base compute engine (entire infrastructure)**
- âœ… `assess/display.py` - Display logic
- âœ… `config/interface.py` - `Interface` class
- âœ… `config/context.py` - `Context` class
- âœ… `security/` - All credential management

**Utilities**:
- âœ… `util/liquid.py` - Template rendering
- âœ… `util/text.py` - Basic string operations
- âœ… `util/files.py` - File utilities
- âœ… `util/yaml.py` - YAML utilities
- âœ… `util/html.py` - HTML utilities
- âœ… `util/misc.py` - General utilities
- âœ… `util/dataframe.py` - Basic DataFrame utilities

**Compute Infrastructure** (all stays in lynguine):
- âœ… Function registry system
- âœ… Argument resolution logic
- âœ… Three-phase processing
- âœ… Cache management
- âœ… Refresh logic
- âœ… Base function implementations (`render_liquid`, `today`)

#### Moves to vongole (Extension Layer)

**Key Insight**: vongole is now **just the assessment-level functions**, not the engine!

- ğŸ”„ New `vongole/compute.py` - **Extends** `lynguine.assess.compute.Compute`
- ğŸ”„ `vongole/functions/text.py` - Advanced text processing (word count, NLP, summarization)
- ğŸ”„ `vongole/functions/dataframe.py` - Aggregations, filtering, sorting, statistics
- ğŸ”„ `vongole/functions/files.py` - PDF extraction, document parsing
- ğŸ”„ `vongole/functions/datetime.py` - Date arithmetic, formatting
- ğŸ”„ `vongole/functions/visualization.py` - Plots, charts, histograms

**What moves**: Just the heavy function implementations, not the infrastructure
#### Needs Analysis

**This architecture is MUCH simpler than originally proposed!**

Since the base compute engine stays in lynguine, most code doesn't need to change:

**`assess/compute.py`**:
- âœ… Stays exactly as is in lynguine
- Just has access-level functions by default
- Can be used directly for access compute
- Can be extended by vongole for assessment compute

**`util/` modules**:
- âœ… All stay in lynguine (no splitting needed)
- vongole can use them via inheritance

**`assess/data.py` (CustomDataFrame)**:
- âœ… Currently imports `Compute` from lynguine - that's fine!
- Can use lynguine's Compute for access-level operations
- Can optionally use vongole's extended Compute for assessment

```python
# Current (works fine!)
from ..assess.compute import Compute

class CustomDataFrame:
    def run_compute(self):
        compute = Compute(self.interface)  # lynguine's base engine
        compute.run_all(self)

# Optional: Use vongole if available for assessment functions
class CustomDataFrame:
    def run_compute(self, compute_class=None):
        if compute_class is None:
            # Try vongole first, fallback to lynguine
            try:
                from vongole import Compute
            except ImportError:
                from ..assess.compute import Compute
        else:
            Compute = compute_class
        
        compute = Compute(self.interface)
        compute.run_all(self)
```

**`access/io.py` (finalize_data)**:
- âœ… Currently uses lynguine's Compute - that's fine!
- Can optionally check for vongole if assessment functions are used

```python
# Current (works fine!)
if "compute" in interface:
    compute = Compute.from_flow(interface)
    # ... compute operations

# Optional enhancement: Auto-detect if vongole needed
if "compute" in interface:
    # Check if any compute functions require vongole
    needs_vongole = any(
        func["function"] in ASSESSMENT_FUNCTIONS 
        for func in interface["compute"]
    )
    
    if needs_vongole:
        try:
            from vongole import Compute
        except ImportError:
            from ..assess.compute import Compute
            log.warning("Assessment functions may not be available")
    else:
        from ..assess.compute import Compute
    
    compute = Compute.from_flow(interface)
```

## Implementation Plan

### Phase 1: Preparation (No Breaking Changes)

**Goal**: Prepare codebase for split without breaking existing functionality

1. **Audit Dependencies**:
   - [ ] Map all imports between access, assess, compute, util
   - [ ] Identify circular dependencies
   - [ ] Document current coupling points

2. **Create Dependency Injection Points**:
   - [ ] Refactor `CustomDataFrame` to accept optional compute engine
   - [ ] Refactor `finalize_data()` to use lazy compute import
   - [ ] Add feature flags for compute operations

3. **Reorganize Utilities**:
   - [ ] Separate compute-related utilities from general utilities
   - [ ] Mark compute utilities with clear comments
   - [ ] Ensure no circular dependencies

4. **Update Tests**:
   - [ ] Separate storage tests from compute tests
   - [ ] Ensure tests can run independently
   - [ ] Add integration tests for storage+compute

**Deliverable**: lynguine codebase ready for extraction, all tests passing

### Phase 2: Create vongole Package

**Goal**: Extract compute functionality into new package

1. **Initialize vongole Repository**:
   - [ ] Create new repository: `lawrennd/vongole`
   - [ ] Set up package structure
   - [ ] Copy VibeSafe infrastructure (CIPs, backlog, tenets)
   - [ ] Set up CI/CD

2. **Extract Compute Code**:
   - [ ] Copy `assess/compute.py` â†’ `vongole/compute.py`
   - [ ] Copy compute-related utilities
   - [ ] Update imports to use lynguine for data structures
   - [ ] Remove compute code from lynguine (keep deprecated stubs)

3. **Set Up vongole Package**:
   - [ ] Create `pyproject.toml` with lynguine dependency
   - [ ] Create `setup.py` for backward compatibility
   - [ ] Add README with clear purpose statement
   - [ ] Set up documentation structure

4. **Test vongole Independently**:
   - [ ] Port compute tests to vongole
   - [ ] Ensure all tests pass
   - [ ] Test with different lynguine versions

**Deliverable**: Working vongole package, published to PyPI (alpha version)

### Phase 3: Backward Compatibility Layer

**Goal**: Maintain backward compatibility in lynguine

1. **Create Deprecated Imports**:
   - [ ] Add `lynguine/assess/compute.py` stub that imports from vongole
   - [ ] Add deprecation warnings
   - [ ] Update documentation with migration guide

```python
# lynguine/assess/compute.py (deprecated stub)
import warnings

warnings.warn(
    "lynguine.assess.compute is deprecated. "
    "Please use 'from vongole import Compute' instead. "
    "This stub will be removed in lynguine 0.3.0",
    DeprecationWarning,
    stacklevel=2
)

try:
    from vongole import Compute
except ImportError:
    raise ImportError(
        "The compute functionality has moved to the 'vongole' package. "
        "Please install it: pip install vongole"
    )
```

2. **Update lynguine Dependencies**:
   - [ ] Add vongole as optional dependency: `pip install lynguine[compute]`
   - [ ] Update documentation
   - [ ] Update examples

3. **Test Backward Compatibility**:
   - [ ] Test old import paths still work (with warnings)
   - [ ] Test with existing referia code
   - [ ] Test with existing lamd code

**Deliverable**: lynguine with backward compatibility, all existing code still works

### Phase 4: Update Downstream Projects

**Goal**: Migrate referia, lamd, and other projects to use vongole

1. **Update referia**:
   - [ ] Change imports from `lynguine.assess.compute` to `vongole`
   - [ ] Add vongole to dependencies
   - [ ] Update referia's compute extensions to inherit from vongole
   - [ ] Test all referia functionality

2. **Update lamd**:
   - [ ] Change imports to use vongole
   - [ ] Add vongole to dependencies
   - [ ] Test all lamd functionality

3. **Update Documentation**:
   - [ ] Update all examples to use vongole
   - [ ] Create migration guide
   - [ ] Update architecture diagrams

**Deliverable**: All downstream projects migrated, using vongole directly

### Phase 5: Cleanup and Finalization

**Goal**: Remove deprecated code, finalize architecture

1. **Remove Deprecated Code** (lynguine 0.3.0):
   - [ ] Remove compute stubs from lynguine
   - [ ] Remove compute-related utilities
   - [ ] Clean up tests

2. **Finalize Documentation**:
   - [ ] Complete lynguine documentation (storage focus)
   - [ ] Complete vongole documentation (compute focus)
   - [ ] Update architecture documentation
   - [ ] Create video/tutorial explaining the separation

3. **Publish Stable Versions**:
   - [ ] Release lynguine 0.3.0 (storage only)
   - [ ] Release vongole 1.0.0 (stable compute)
   - [ ] Announce the change

**Deliverable**: Clean architecture, stable releases, complete documentation

## Backward Compatibility

### Compatibility Strategy

**Three-Phase Approach**:

1. **Phase 1 (lynguine 0.2.x + vongole 0.1.x)**: Full backward compatibility
   - Old imports work with deprecation warnings
   - `pip install lynguine[compute]` installs vongole automatically
   - No breaking changes

2. **Phase 2 (lynguine 0.2.x + vongole 0.2.x - 0.9.x)**: Deprecation period
   - Maintain deprecated stubs for 6-12 months
   - Clear migration documentation
   - Automated migration tools

3. **Phase 3 (lynguine 0.3.0 + vongole 1.0.0)**: Clean break
   - Remove deprecated code
   - Require explicit vongole import
   - Clear, separated architecture

### Migration Path for Users

**For users who want compute functionality**:

```bash
# Old (still works in 0.2.x)
pip install lynguine

# New (recommended)
pip install lynguine vongole

# Or use convenience extra
pip install lynguine[compute]
```

**For users who only need storage**:

```bash
# Just install lynguine
pip install lynguine
# Smaller dependency footprint, faster install
```

### Code Migration

**Automatic migration tool**:

```bash
# Tool to update imports automatically
python -m vongole.migrate /path/to/project
```

**Manual migration**:

```python
# Old
from lynguine.assess.compute import Compute

# New
from vongole import Compute
```

### Version Compatibility Matrix

| lynguine | vongole | Status | Notes |
|----------|---------|--------|-------|
| 0.1.x | N/A | Legacy | Compute in lynguine |
| 0.2.x | 0.1.x - 0.9.x | Transition | Deprecated stubs |
| 0.3.x+ | 1.0.x+ | Stable | Clean separation |

## Testing Strategy

### Unit Tests

**lynguine tests** (storage focus):
- [ ] Data loading from all sources (CSV, Excel, YAML, Google Sheets)
- [ ] CustomDataFrame operations (without compute)
- [ ] Interface and Context configuration
- [ ] Security/credential management
- [ ] File utilities
- [ ] All tests pass without vongole installed

**vongole tests** (compute focus):
- [ ] Compute engine functionality
- [ ] Function registry
- [ ] Argument resolution (row_args, column_args, etc.)
- [ ] Three-phase processing
- [ ] All compute functions
- [ ] All tests pass with lynguine installed

### Integration Tests

- [ ] lynguine + vongole together
- [ ] Compute operations on CustomDataFrame
- [ ] Full data flow: load â†’ compute â†’ output
- [ ] Backward compatibility (deprecated imports)

### Downstream Tests

- [ ] referia test suite passes
- [ ] lamd test suite passes
- [ ] Example notebooks run successfully

### Performance Tests

- [ ] Import time (lynguine without vongole should be faster)
- [ ] Memory usage (smaller footprint without compute)
- [ ] Compute performance (should be unchanged)

## Alternatives Considered

### Alternative 1: Keep Everything in lynguine

**Rejected**: Doesn't address the architectural issues, continues tight coupling

**Pros**:
- No migration needed
- Simpler for users (one package)

**Cons**:
- Violates separation of concerns
- Makes dependencies unclear
- Harder to test independently
- Doesn't align with DOA principles

### Alternative 2: Three Packages (lynguine-core, lynguine-storage, lynguine-compute)

**Rejected**: Too much fragmentation

**Pros**:
- Maximum modularity
- Could share core interfaces

**Cons**:
- Too complex for users
- Maintenance burden
- Unclear where things belong

### Alternative 3: Plugins/Extensions Pattern

**Rejected**: Doesn't provide clean separation

**Pros**:
- Flexible
- Could support multiple compute engines

**Cons**:
- Still requires tight coupling for core functionality
- More complex implementation
- Doesn't solve the fundamental architecture issue

### Alternative 4: Monorepo with Multiple Packages

**Considered**: Could be future enhancement

**Pros**:
- Easier to coordinate changes
- Shared CI/CD
- Atomic commits across packages

**Cons**:
- More complex repository structure
- Requires tooling (e.g., lerna, nx)

**Decision**: Start with separate repos, consider monorepo later if needed

## Risks and Mitigations

### Risk 1: Breaking Existing Code

**Likelihood**: High (without mitigation)
**Impact**: High

**Mitigation**:
- Maintain backward compatibility stubs
- Provide automated migration tools
- Clear deprecation timeline (6-12 months)
- Comprehensive migration documentation

### Risk 2: Increased Maintenance Burden

**Likelihood**: Medium
**Impact**: Medium

**Mitigation**:
- Shared CI/CD infrastructure
- Consistent coding standards
- Clear ownership and responsibilities
- Consider monorepo in future

### Risk 3: User Confusion

**Likelihood**: Medium
**Impact**: Medium

**Mitigation**:
- Clear documentation explaining the split
- Migration guide with examples
- Video tutorials
- Active support during transition

### Risk 4: Version Compatibility Issues

**Likelihood**: Medium
**Impact**: Medium

**Mitigation**:
- Semantic versioning
- Clear compatibility matrix
- Integration tests across versions
- Pin dependencies appropriately

### Risk 5: Incomplete Separation

**Likelihood**: Low
**Impact**: High

**Mitigation**:
- Thorough dependency audit before split
- Comprehensive testing
- Gradual migration approach
- Ability to roll back if needed

## Success Criteria

### Technical Success

- [ ] lynguine can be installed and used without vongole
- [ ] vongole works correctly with lynguine
- [ ] All tests pass in both packages
- [ ] No circular dependencies
- [ ] Import time reduced for lynguine-only usage
- [ ] Clear dependency boundaries

### User Success

- [ ] Existing code continues to work (with deprecation warnings)
- [ ] Migration guide is clear and comprehensive
- [ ] Users understand the separation and benefits
- [ ] No major complaints or issues during transition
- [ ] Downstream projects (referia, lamd) successfully migrated

### Documentation Success

- [ ] Architecture clearly documented
- [ ] Migration guide complete
- [ ] Examples updated
- [ ] API documentation accurate
- [ ] Tutorial videos created

## Timeline

**Estimated Duration**: 3-4 months

- **Phase 1 (Preparation)**: 3-4 weeks
- **Phase 2 (Create vongole)**: 3-4 weeks
- **Phase 3 (Backward Compatibility)**: 2 weeks
- **Phase 4 (Update Downstream)**: 3-4 weeks
- **Phase 5 (Cleanup)**: 2 weeks
- **Buffer for issues**: 2-3 weeks

**Deprecation Period**: 6-12 months after Phase 3 completion

## Related Work

### Related CIPs

- [CIP-0005](./cip0005.md): Secure Credential Management (stays in lynguine)
- [CIP-0006](./cip0006.md): (if relevant to architecture)

### Related Backlog Items

- [2025-12-22_investigate-compute-integration-for-config-sections](../backlog/infrastructure/2025-12-22_investigate-compute-integration-for-config-sections.md): Related investigation into compute architecture

### Related Tenets

- [Explicit Infrastructure](../tenets/lynguine/explicit-infrastructure.md): This CIP directly supports this tenet
- [Flow-Based Processing](../tenets/lynguine/flow-based-processing.md): This CIP aligns with access-assess-address pattern

## Open Questions

1. **Access Compute Boundary**: Have we drawn the line correctly between access and assessment compute?
   - **Current approach**: Access compute stays in lynguine (template rendering, index construction, path resolution)
   - **Concern**: Is liquid template rendering too heavy for lynguine?
   - **Resolution**: Liquid is lightweight and essential for basic data access patterns like `{{familyName}}_{{givenName}}`
   - **Status**: Addressed - keep template rendering in lynguine

2. **Naming**: Is "vongole" the right name? (It's pasta-themed like lynguine, which is good)
   - Alternative names: `lynguine-compute`, `assess`, `transform`
   - **Recommendation**: Keep "vongole" - it's distinctive and pasta-themed

3. **Address Stage**: Should we plan for a third package for the "address" stage?
   - **Recommendation**: Not yet, wait to see patterns emerge

4. **Shared Utilities**: Should there be a `lynguine-common` package?
   - **Recommendation**: No, keep access-level utilities in lynguine, vongole depends on lynguine

5. **Versioning**: Should versions be synchronized (lynguine 1.0 + vongole 1.0)?
   - **Recommendation**: Independent versioning, but document compatibility

6. **Repository Structure**: Separate repos or monorepo?
   - **Recommendation**: Start with separate repos, consider monorepo later

## Implementation Status

- [ ] Phase 1: Preparation
  - [ ] Audit dependencies
  - [ ] Create dependency injection points
  - [ ] Reorganize utilities
  - [ ] Update tests
- [ ] Phase 2: Create vongole package
  - [ ] Initialize repository
  - [ ] Extract compute code
  - [ ] Set up package
  - [ ] Test independently
- [ ] Phase 3: Backward compatibility
  - [ ] Create deprecated imports
  - [ ] Update dependencies
  - [ ] Test compatibility
- [ ] Phase 4: Update downstream projects
  - [ ] Update referia
  - [ ] Update lamd
  - [ ] Update documentation
- [ ] Phase 5: Cleanup
  - [ ] Remove deprecated code
  - [ ] Finalize documentation
  - [ ] Publish stable versions

## References

- [Data Oriented Architecture Principles](https://en.wikipedia.org/wiki/Data-oriented_design)
- [Separation of Concerns](https://en.wikipedia.org/wiki/Separation_of_concerns)
- [Semantic Versioning](https://semver.org/)
- [Python Packaging Guide](https://packaging.python.org/)

## Notes

This CIP represents a significant architectural change that will improve the long-term maintainability and clarity of the lynguine ecosystem. The key to success is maintaining backward compatibility during the transition and providing excellent documentation and tooling for migration.

The separation aligns with the project's DOA principles and the access-assess-address pattern, making the architecture more explicit and easier to understand.

## Author and Dates

- **Author**: Neil Lawrence
- **Created**: 2025-12-24
- **Status**: Proposed
- **Last Updated**: 2025-12-24