---
id: "cip0003"
title: "Consistent Mapping Initialization Across lynguine and referia"
status: "Proposed"
priority: "High"
effort: "Medium"
type: "design-consistency"
created: "2025-10-10"
last_updated: "2025-10-10"
owner: "lawrennd"
github_issue: null
dependencies: null
---

# CIP-0003: Consistent Mapping Initialization Across lynguine and referia

## Status

- [x] Proposed: 2025-10-10
- [ ] Accepted
- [ ] Implemented
- [ ] Closed

## Description

There is a design inconsistency between `lynguine` (a Data Oriented Architecture library) and `referia` (a user-oriented reviewing tool built on lynguine) regarding when column-to-variable mappings are created:

- **lynguine**: Mappings are only created during `from_flow()` processing (line 1102) or in `_finalize_df()` (line 2964). Direct construction leaves mappings empty until data flows are processed.
- **referia**: Overrides `__init__` to immediately call `_augment_column_names()` (line 180), pre-populating mappings for all data types before any flow processing.

This divergence exists because referia needs mappings available early for user-facing review workflows, but it creates a timing issue: when referia's `CustomDataFrame` is used with `from_flow()`, mappings are created **twice**:
1. First in `__init__` (creating identity mappings like `job_title -> job_title` for valid column names)
2. Then during `from_flow()` (attempting to apply explicit interface mappings like `jobTitle: job_title`)

This creates a **timing conflict**: referia's `__init__` creates identity mappings (like `job_title -> job_title`) that later conflict when `from_flow()` tries to apply explicit interface mappings (like `jobTitle: job_title`).

## Motivation

### Understanding the Architecture

**lynguine** is a Data Oriented Architecture (DOA) library implementing flow-based data processing. It provides:
- General-purpose data stream infrastructure
- `CustomDataFrame` for managing data flows
- Interface specifications for inputs/outputs
- Compute operations for transformations

**referia** is a user-oriented reviewing tool that provides "convenience functionality for ease of creation of reviewing software." It:
- Builds on lynguine's DOA infrastructure
- Uses Jupyter notebooks as interface
- Provides review widgets and assessment workflows
- Needs mappings available early for user interaction

### Current Problems

1. **Fragile interaction**: When referia uses `from_flow()`, mappings are created twice, leading to conflicts
2. **Hidden complexity**: The recent bug (2025-10-09_mapping-conflict-with-identity-mappings) required understanding referia's override behavior
3. **Testing difficulty**: Bug was impossible to reproduce using lynguine's `CustomDataFrame` directly - tests had to patch `__init__` to mimic referia
4. **Workaround accumulation**: We fixed the symptom (allow identity mapping override) rather than addressing the design issue
5. **Timing conflict**: referia's `__init__` creates identity mappings that conflict with `from_flow()`'s explicit interface mappings
6. **Unclear responsibilities**: Should early mapping creation be infrastructure concern (lynguine) or application concern (referia)?

### Questions This CIP Should Answer

1. **Is early mapping creation an infrastructure or application concern?**
   - Infrastructure (lynguine): Always provide mappings after construction
   - Application (referia): Only referia needs early mappings for user workflows

2. **Why does referia need early mappings?**
   - Review workflows may need to reference columns by variable names before `from_flow` completes
   - User-facing widgets need access to mapped names immediately

3. **Why does the timing matter?**
   - referia's `__init__` creates identity mappings (e.g., `job_title -> job_title`) immediately
   - Later, `from_flow()` tries to apply explicit interface mappings (e.g., `jobTitle: job_title`)
   - This causes conflicts because the identity mapping already exists

4. **What is the right architectural solution?**
   - Option A: Move to lynguine (makes it infrastructure concern, everyone gets eager mappings)
   - Option B: Keep in referia but fix timing (defer until after `from_flow` completes)
   - Option C: Keep in referia as-is (requires identity mapping override fix to stay)

## Implementation

### Recommendation: Option B

Option B is recommended because:
1. **Respects layering**: Keeps application-specific behavior in referia
2. **Fixes timing**: Explicit interface mappings applied before augmentation
3. **Maintains functionality**: Referia still gets early mappings
4. **Clear responsibility**: lynguine = infrastructure, referia = application convenience

### Option A: Move to Eager Initialization in lynguine

Make lynguine's `CustomDataFrame.__init__` call `_augment_column_names()` after `_distribute_data()`:

```python
# In CustomDataFrame.__init__, after line 2326:
self._distribute_data(data)

# Add this:
for typ in self._d:
    self._augment_column_names(self._d[typ])
```

**Pros:**
- Consistent behavior across lynguine and referia
- Mappings always available when expected
- Simplifies referia (can remove its override)
- Makes behavior more predictable

**Cons:**
- Slight performance cost (mappings created even if never used)
- May create mappings that are later overridden by `from_flow`

**Migration Path:**
1. Add to lynguine's `__init__`
2. Test with existing lynguine test suite
3. Test with referia (mappings called twice, should be idempotent)
4. Remove from referia's `__init__`

### Option B: Keep in referia, Fix Timing (Recommended)

Keep the eager mapping behavior in referia (as it's application-specific), but defer the `_augment_column_names` call until **after** `from_flow()` completes by overriding `from_flow()` instead of `__init__`.

```python
# In referia's CustomDataFrame
@classmethod
def from_flow(cls, interface):
    # Call parent from_flow
    cdf = super().from_flow(interface)
    # Now augment mappings for any columns that don't have explicit mappings
    for typ in cdf._d:
        cdf._augment_column_names(cdf._d[typ])
    return cdf
```

**Pros:**
- Keeps application-specific behavior in application code
- Respects DOA layering (infrastructure vs application)
- Fixes the timing issue properly
- Mappings still available when referia needs them
- Explicit interface mappings take precedence by being applied first

**Cons:**
- Referia still diverges from lynguine (but appropriately)
- Requires understanding the timing of mapping creation

### Option C: Remove from referia, Keep Lazy in lynguine

Remove the `_augment_column_names` call from referia's `__init__` entirely.

**Pros:**
- Eliminates divergence between lynguine and referia
- Simpler, more minimal approach

**Cons:**
- May break existing referia code that expects mappings after construction
- Referia may need mappings earlier than `from_flow` provides them
- High risk without audit of referia's codebase

### Option D: Document and Keep Current Workaround

Keep current behavior with identity mapping override fix in place.

**Pros:**
- No further code changes needed
- Currently working

**Cons:**
- Doesn't address root cause (timing issue)
- Perpetuates architectural confusion
- Future maintenance burden

## Implementation Plan

**Recommendation: Option B (Fix Timing in referia)**

### Phase 1: Move augmentation to from_flow in referia (Low risk)
- [ ] Remove `_augment_column_names` call from referia's `__init__` (lines 178-180)
- [ ] Override `from_flow()` in referia to call `_augment_column_names()` after parent completes
- [ ] Run existing referia test suite
- [ ] Verify mappings are available after `from_flow` completes

### Phase 2: Verify no regressions (Medium risk)
- [ ] Test that explicit interface mappings take precedence
- [ ] Ensure identity mapping override fix is still needed (it should be)
- [ ] Check review workflows still have access to mappings when needed
- [ ] Verify computed index columns work correctly

### Phase 3: Documentation (Low risk)
- [ ] Document that referia provides eager mapping creation as application-specific convenience
- [ ] Explain timing: explicit mappings applied before augmentation
- [ ] Note this is why identity mapping override is necessary

## Backward Compatibility

**For lynguine users:**
- No changes (lynguine behavior unchanged)
- Mappings remain lazy (created during flow processing)

**For referia users:**
- No observable changes in behavior
- Mappings still available after `from_flow()`
- Internal timing improved (explicit mappings take precedence)
- Fix reduces likelihood of future mapping conflicts

## Testing Strategy

1. Verify existing test (`test_identity_mapping_referia.py`) still passes
2. Add test for referia's `from_flow()` override
3. Test that explicit interface mappings take precedence over identity mappings created in `__init__`
4. Verify computed index columns (like `Name` from liquid templates) work correctly
5. Run full referia test suite

## Examples of Non-Intuitive Behavior

### Example 1: Unexpected Mappings After Construction

```python
import pandas as pd
from lynguine.assess.data import CustomDataFrame

# User creates data
data = pd.DataFrame({
    'job_title': ['Engineer', 'Manager', 'Analyst'],
    'name': ['Alice', 'Bob', 'Charlie']
})

# User expects: Empty mappings after construction
cdf = CustomDataFrame(data=data)
print(f"Expected: {{}}")
print(f"Actual: {cdf._name_column_map}")  # {} in lynguine

# But in referia (simulated):
cdf._augment_column_names(data)  # referia does this in __init__
print(f"Referia: {cdf._name_column_map}")  # {'job_title': 'job_title', 'name': 'name'}
```

**User confusion**: "I didn't ask for these mappings! Why do they exist?"

### Example 2: Inconsistent Behavior Between Libraries

```python
# Same operation, different behavior
data = pd.DataFrame({'job_title': ['Engineer']})

# lynguine behavior
cdf1 = CustomDataFrame(data=data)
print(f"lynguine mappings: {cdf1._name_column_map}")  # {}

# referia behavior (simulated)
cdf2 = CustomDataFrame(data=data)
cdf2._augment_column_names(data)  # referia __init__
print(f"referia mappings: {cdf2._name_column_map}")  # {'job_title': 'job_title'}
```

**User confusion**: "Why does the same code behave differently?"

### Example 3: Hidden Override Behavior

```python
# User specifies interface mapping
cdf.update_name_column_map('jobTitle', 'job_title')

# User expects: jobTitle -> job_title
# User gets: jobTitle -> job_title (but job_title -> job_title disappeared!)
print(f"Result: {cdf._name_column_map}")  # {'jobTitle': 'job_title'}
```

**User confusion**: "Where did my original mapping go? Why did it disappear?"

### Example 4: Unpredictable Mapping State

```python
# User can't predict when mappings will exist
cdf = CustomDataFrame(data=data)

# Question: Are mappings populated?
# Answer: Depends on which library you're using!
# - lynguine: No, mappings created during flow processing
# - referia: Yes, mappings created in __init__

# User has to know implementation details to predict behavior
```

**User confusion**: "I need to understand internal implementation to use the library?"

## Implementation Status

- [ ] Phase 1: Move augmentation to from_flow in referia
- [ ] Phase 2: Verify no regressions
- [ ] Phase 3: Documentation

## References

- Bug: `backlog/bugs/2025-10-09_mapping-conflict-with-identity-mappings.md`
- Investigation: `backlog/infrastructure/2025-10-09_investigate-mapping-test-failure.md`
- Referia commit 49cea11: Added augment call to referia `__init__`
- Code files:
  - `lynguine/assess/data.py`, lines 2247-2381 (CustomDataFrame.__init__)
  - `lynguine/assess/data.py`, lines 3014-3048 (_augment_column_names)
  - `referia/assess/data.py`, lines 178-180 (referia's __init__ override)

## Author and Date

- **Author**: lawrennd
- **Date**: 2025-10-10
